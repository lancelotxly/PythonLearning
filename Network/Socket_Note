1. Socket Base: 1) DEFINIE:
                           Application
                          *Socket
                           TCP/UDP
                           IP
                           Datalink
                           Physics

                 2) Classify:    AF_UNIX   #file-socket
                                 AF_INET   #net-socket

                 3) IP_PORT = ('ip_addr',port)   #标识唯一程序


2. TCP/IP:      1. FLOW:
                       SERVER                                                        CLIENT
                       #1. tcp_server = socket(AF_INET, STREAM)                      1. tcp_client = socket(AF_INET, STREAM)
                       #2. tcp_server.bind(ip_port)                                  2. tcp_client.connect_ex(ip_port)
                       #3. tcp_server.listen(num)
                       ---- Prepare-------------------

                       #4. conn, addr = tcp_server.accept()
                       ----Listen & Build connection--

                       #5. conn.recv([BUFSIZE])/send()                               3. tcp_client.recv([BUFSIZE])/send()
                       ----Read & Send msg(bytes)-----

                       #6. conn.close()                                              4. tcp_client.close()
                       ----Close connection----------                                ---Disconnect and Close socket----
                       #7. tcp_server.close()
                       ----Close socket--------------

                2. TIPS:
                        #1. 服务端程序两次阻塞: 1) tcp_server.accpet()    等待客户端接入, 没有则程序卡住; 有多个连接，则将其存入缓冲区, 处理完当前连接，再处理下一个
                                                                      # 没有实现并发

                                             2) conn.recv()           服务器从自己的内核态内存中取数据, 没有数据则卡住

                        #2. 客户端的一次阻塞:   1） tcp_client.recv()     客户端从自己的内核态内存中取数据, 没有则卡住

                        #3. TCP基于数据流, 不允许收发为空

                        #4. 要先启动服务器, 再启动客户端


3.  UDP/IP:     1. FLOW:
                       SERVER                                                        CLIENT
                       #1. udp_server = socket(AF_INET, STREAM)                      1. udp_client = socket(AF_INET, STREAM)
                       #2. udp_server.bind(ip_port)
                       ---- Prepare-------------------

                       #3. udp_server..recvfrom([BUFSIZE])/sendto(msg,addr)          2. udp_client.recvfrom([BUFSIZE])/sendto(msg,addr)
                       ----Read & Send msg(bytes)-----

                       #6. udp_server.close()                                        3. udp_client.close()
                       ----Close connection & Socket----------                        ---Disconnect and Close socket----

                2. TIPS:
                       #1. 服务器和客户端各只有一次阻塞: 1) udp_server.recvfrom()          udp_client.recvfrom()

                       #2. UDP基于消息, 可以发空, 收空则阻塞

                       #3. 不存在启动顺序, 因为是无连接的

                       #3. 服务器和客户端实质上是对等网络, 只不过服务器明确绑定了ip_port


4. TCP & UDP 区别:
                 #1. TCP面向数据流,  TCP底层会把多次间隔较小且数据量小的数据, 合并成一个大的数据块, 然后进行封包; 接收方根本不知道该文件的字节流从何处开始，在何处结束
                     UDP面向数据报,  有消息保护边界, 每个UDP包中有消息头（消息来源地址，端口等信息); 接收端容易进行区分处理了

                 #2. TCP的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的, 会粘包
                     UDP一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y>x数据就丢失，这意味着UDP根本不会粘包，但是会丢数据，不可靠


5. 粘包:  1）DEFINE:
                  接收方不知道消息之间的界限, 只有TCP会粘包, UDP不会粘包

         2) Classify:
                     #1. 发送端, 短时间内发送多次数据, TCP会主动将数据合在一起

                     #2. 接收端, 一次没有接收完, 下次接着接收


         3) Solution:  发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据


6. socketserver:
                1) DEFINE:
                         #1. Server类(解决连接):
                                                                +------------+
                                                                | BaseServer |
                                                                +------------+
                                                                      ^
                                                                      |
                                                                +-----------+        +------------------+
                                                            |-->| TCPServer |<-------| UnixStreamServer |
                                                            |   +-----------+        +------------------+
                +--------------------+                      |          ^
                | ThreadingMixIn     | <-----------|        |          |
                +--------------------+             |        |          |
                         ^                         |        |          |
                         |                         |        |     +-----------+        +--------------------+
                         |                         |        |     | UDPServer |<-------| UnixDatagramServer |
                         |                         |        |     +-----------+        +--------------------+
                +--------------------+             |        |           ^
                | ThreadingTCPServer | ------------|--------|           |
                +--------------------+             |                    |
                                                   |                    |
                                            +--------------------+      |
                                            | ThreadingUDPServer |------|
                                            +--------------------+

                         #2. Request类: 解决通信
                                                 +--------------------+
                                     |---------> | BaseRequestHandler |<-----|
                                     |           +--------------------+      |
                                     |                               +----------------------+
                                     |                               | StreamRequestHandler |
                                     |                               +----------------------+
                            +----------------------+
                            | StreamRequestHandler |
                            +----------------------+

                2) Flow:
                        TCP
                           1> s = socketserver.ThreadingTCPServer(IP_PORT,MyServer)
                              注册服务器, 绑定自己的RequestHandler方法
                                 #1. BaseServer.__init__(IP_PORT,MyServer)
                                        s.server_address = 服务器IP_PORT
                                        s.RequestHandlerClass = MyServer
                                 #2. TCPServer
                                        s.socket = 创建socket对象
                                        s.server_bind() --> s.socket.bind() = 绑定服务器IP_PORT
                                        s.server_active() --> s.socket.listen() = 服务器监听

                           2> s.server_forever()
                               开启一个线程建立连接, 并执行MyServer类的handler方法处理连接请求
                               #1. BaseServer.server_forever() --> _handle_request_noblock()
                               #2. --> TCPServer.get_request() --> s.socket.accept()  建立连接
                               #3. --> ThreadingMixIn.process_request()--> process_request_thread  为该连接创建一个线程
                               #4. --> BaseServer.finish_request() --> s.MyServer() 创建处理请求的对象
                               #5. --> BaseRequestHandler() --> self.request = con
                                                                self.client_address = client_address
                                                                self.server = s为服务器对象
                                                                self.handle()

                        UDP:
                            1> s = socketserver.ThreadingUDPServer(IP_PORT, MyServer)
                               #1. BaseServer.__ini__(IP_PORT,MyServer)
                                   s.server_address = 服务器IP_PORT

                               #2. TCPServer
                                   s.socket = 创建socket对象        self.type = socket.SOCK_DGRAM
                                   s.server_bind() --> s.socket.bind()  = 绑定服务器IP_PORT
                                   s.server_active(): pass

                            2>. s.server_forever()
                               #1. BaseServer.server_forever() --> _handle_request_noblock()
                               #2. --> UDPServer.get_request() --> s.socket.recvfrom(self.max_packet_size=8192)
                                                                   return ((data, s.socket), client_addr)
                               #3. --> ThreadingMixIn.process_request()--> process_request_thread  为该连接创建一个线程
                               #4. --> BaseServer.finish_request() --> s.MyServer() 创建处理请求的对象
                               #5. --> BaseRequestHandler() --> self.request = (data, s.socket)
                                                                self.client_address = client_address
                                                                self.server = s为服务器对象
                                                                self.handle()